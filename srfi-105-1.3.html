<!--
SPDX-FileCopyrightText: 2012 Alan Manuel K. Gloria
SPDX-FileCopyrightText: 2012 David A. Wheeler

SPDX-License-Identifier: MIT
-->

<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
<head>
<title>SRFI 105: Curly-infix-expressions</title>
<meta content="text/html; charset=us-ascii" http-equiv="content-type">
</head>
<body>

<!-- This commented out text is for the brittle SRFI tools -->
<!--
<H1>Title</H1>

Curly-infix-expressions

<H1>Author</H1>

David A. Wheeler, Alan Manuel K. Gloria

<H1>Status</H1>

This SRFI is currently in ``draft'' status.
-->
<h1 id="title">Title</h1>
<p>Curly-infix-expressions</p>

<h1 id="author" id="authors">Authors</h1>
<p><a href="http://www.dwheeler.com">David A. Wheeler</a></p>
<p>Alan Manuel K. Gloria</p>

<h1 id="status">Status</h1>
<p>
This SRFI is currently in ``draft'' status.  To see an explanation of
each status that a SRFI can hold, see <a
href="http://srfi.schemers.org/srfi-process.html">here</a>.

To provide input on this SRFI, please
<a href="mailto:srfi minus 105 at srfi dot schemers dot org">mail to
<code>&lt;srfi minus 105 at srfi dot schemers dot org&gt;</code></a>.  See
<a href="../../srfi-list-subscribe.html">instructions here</a> to
subscribe to the list.  You can access previous messages via
<a href="mail-archive/maillist.html">the archive of the mailing list</a>.
</p>

<ul>
      <li>
	Received: <a href="http://srfi.schemers.org/srfi-105/srfi-105-1.2.html">2012/08/22</a></li>

      <li>Draft: 2012/08/22-2012/10/22</li>
      <li>Revision: <a href="http://srfi.schemers.org/srfi-105/srfi-105-1.3.html">2012/09/03</a></li>
</ul>

<h1><a name="related-srfis">Related SRFIs</a></h1>
<p>None</p>

<h1><a name="abstract">Abstract</a></h1>
<p>Lisp-based languages, like Scheme, are almost the only
programming languages in modern use that do not support infix notation.
In addition, most languages allow infix expressions to be combined
with function call notation of the form f(x).
This SRFI provides these capabilities, both for
developers who already use Scheme and want these conveniences,
and also for other developers who may choose to use other languages
in part because they miss these conveniences.
Scheme currently reserves <code>{</code>...<code>}</code>
&#8220;for possible future extensions to the language&#8221;.
We propose that <code>{</code>...<code>}</code> be used
to support &#8220;curly-infix&#8221; notation as a homoiconic
infix abbreviation,
as a modification of the Scheme reader.
It is an abbreviation in much the same way that
<samp>&#39;x</samp> is an abbreviation for <samp>(quote&nbsp;x)</samp>.
</p>
<p>
A
<a href="#specification"><dfn>curly-infix list</dfn></a>
introduces a list whose visual presentation
is in infix order instead of prefix order.
For example,
<samp>{n&nbsp;&gt;&nbsp;2}</samp> &#8658; <samp>(&gt;&nbsp;n&nbsp;2)</samp>,
and
<samp>{a&nbsp;+&nbsp;b&nbsp;+&nbsp;c}</samp> &#8658;
<samp>(+&nbsp;a&nbsp;b&nbsp;c)</samp>.
By intent, there is no precedence, but e.g.,
<samp>{x&nbsp;+&nbsp;{y&nbsp;*&nbsp;z}}</samp>
maps cleanly to
<samp>(+&nbsp;x&nbsp;(*&nbsp;y&nbsp;z))</samp>.
Forms with mixed infix operators and other complications have
&#8220;<var>nfx</var>&#8221; prepended to
enable later macro processing, e.g.,
<samp>{2&nbsp;+&nbsp;3&nbsp;*&nbsp;5}</samp> &#8658;
<samp>(nfx&nbsp;2&nbsp;+&nbsp;3&nbsp;*&nbsp;5)</samp>.
Also, inside a curly-infix list (recursively),
expressions of the form <samp>f(...)</samp> are simply
an abbreviation for <samp>(f&nbsp;...)</samp>.</p>

<p>Note that this is derived from the
&#8220;<a href="http://readable.sourceforge.net/">readable</a>&#8221;
project.
We intend to later submit at least one additional SRFI that will build on
top of this SRFI, but curly-infix-expressions are useful on their own.
</p>

<h1><a name="rationale">Rationale</a></h1>
<p>Lisp-based languages, like Scheme, are almost the only
programming languages in modern use that do not support infix
notation. Even some Lisp advocates, like Paul Graham, admit that
they &#8220;don&#8217;t find prefix math expressions
natural&#8221; (<a href="http://www.paulgraham.com/pypar.html"
rel="nofollow">http://www.paulgraham.com/pypar.html</a>) even after
decades of experience with Lisp-based languages.
Paul Prescod has said, &#8220;I have more faith that you could convince
the world to use Esperanto than prefix notation&#8221;
(<a href="http://people.csail.mit.edu/gregs/ll1-discuss-archive-html/msg01571.html" rel="nofollow">http://people.csail.mit.edu/gregs/ll1-discuss-archive-html/msg01571.html</a>).
Infix is not going away; standard mathematical notation uses infix,
infix notation is taught to most people (programmers or not) in school,
and nearly all new programming languages include infix.
</p>
<p>
Adding infix support to Scheme would be a useful convenience for
some existing developers who use Scheme, and it would also
eliminate a common complaint
by developers who currently choose to use other languages instead.
</p>
<p>Scheme currently reserves
<code>{</code>...<code>}</code> &#8220;for possible future
extensions to the language&#8221;. We propose that
<code>{</code>...<code>}</code> be used to
support &#8220;curly-infix&#8221; notation as a reader
abbreviation, just as
<samp>&#39;x</samp> is an abbreviation for <samp>(quote&nbsp;x)</samp> and
<samp>(x&nbsp;y&nbsp;z)</samp>
is an abbreviation for
<samp>(x&nbsp;.&nbsp;(y&nbsp;.&nbsp;(z&nbsp;.&nbsp;())))</samp>.
</p>
<p>This proposal is an extremely <em>simple</em> and
<em>straightforward</em> technique for supporting infix notation.
There is no complex precedence system, all other Scheme
capabilities (including macros and quasiquoting) work unchanged,
any symbol can be used as an infix operation where desired,
and Scheme remains general and homoiconic.
Curly-infix-expressions (also known as c-expressions)
are just a convenient reader abbreviation for infix notation.</p>
<p>At its core, this SRFI provides
the <em>simple</em> curly-infix list that a list of expressions,
with the difference that values are written in a different order.
The simple curly-infix list
<samp>{operand-1 operator operand-2 operator operand-3 operator ...}</samp>
is mapped to
<samp>(operator operand-1 operand-2 operand-3 ...)</samp> so that more than
two operands are handled cleanly.
E.g., <samp>{a&nbsp;+&nbsp;b&nbsp;+&nbsp;c}</samp> &#8658;
<samp>(+&nbsp;a&nbsp;b&nbsp;c)</samp>.</p>

<h2><a name="rationale_changereader">Why not macros? Why replace the reader?</a></h2>
<p>Many previous systems have implemented &#8220;infix&#8221;
systems as a named macro or procedure (e.g., <var>INFIX</var>).
This looks ugly, and it does the wrong thing &#8212; the resulting list
always has <var>INFIX</var> at the beginning,
not the actual infix operator, so this
approach can interfere with quoting, macros, and other capabilities.
In particular,
consider the following <var>syntax-rules</var> macro
for function composition:
</p>
<pre>
(define-syntax o
  (syntax-rules ()
    ({f o g}
     (lambda args
       (f (apply g args))))
    ({f o g o h o ...}
     {(lambda (x)
        (f (g x))) o h o ...})))
</pre>
<p>
This example takes advantage of the fact that
<samp>{f&nbsp;o&nbsp;g&nbsp;o&nbsp;h&nbsp;o&nbsp;...}</samp>
&#8658; <samp>(o&nbsp;f&nbsp;g&nbsp;h&nbsp;...)</samp>.
Infix cannot be implemented as a macro alone,
as the <var>syntax-rules</var> form has
a particular treatment for the pattern.
A macro for infix would very likely confuse
the <var>syntax-rules</var> form.
</p>

<h2><a name="rationale_othersyntax">Why not a completely different notation for infix?</a></h2>
<p>Other systems build notations into the reader, but the
infix notation are often a notation radically different from
normal Lisp notation.
The result, in some cases, would be that these notations would
simultaneously lose Lisp&#8217;s abilities for
quoting, quasiquoting, and so on, and these notations were
not homoiconic.
</p>
<p>
In contrast, this curly-infix-expression proposal avoids these problems.
For example, in curly-infix,
<samp>&#96;{,a&nbsp;+&nbsp;,b}</samp>
maps cleanly to
<samp>&#96;(+&nbsp;,a&nbsp;,b)</samp>,
which works as expected with all macros.</p>

<h2><a name="rationale_noprecedence">Why isn&#8217;t precedence part of this SRFI?</a></h2>
<p>Many past &#8220;infix&#8221; systems for Lisp build in
precedence. However, Lisp systems often process other languages,
and they may freely mix these different languages.
Thus, the same symbol may have different meanings
and precedence levels in different contexts.
The symbol might not even be defined where it is being
used, and allowing precedence definitions would create subtle errors
if files are read in a different order.
If users hook in their own precedence system into a reader, it could
even become difficult to combine code written for different precedence systems.
In short, building precedence into a
Lisp reader creates many complexities.</p>
<p>Yet the complexity of precedence systems is often unnecessary.
In practice, we&#8217;ve found that simple infix is all
that&#8217;s needed most of the time in Lisp-based languages.
Even in other languages, many developers unnecessarily use
grouping symbols with infix operators to make their order clear.
Thus, requiring grouping symbols is less of a
hardship than it might appear.</p>
<p>By intentionally <em>not</em>
building a precedence system into the reader,
a very simple yet useful infix system results.
We don&#8217;t need to register procedures, ensure that declarations
of precedence precede their use, or anything like it.
We also ensure that the notation is clearly homoiconic.</p>
<p>Instead, where precedence is desired, application and library writers
can implement precedence by defining and controlling the scope of an
&#8220;<var>nfx</var>&#8221; macro or procedure, or by later postprocessing
of that symbol.
Scheme macros are already quite powerful and capable of handling this;
in these cases, <code>{</code>...<code>}</code> provides a more
convenient notation.
The curly-infix approach, instead of trying to manage both infix
and precedence, handles simple cases and then
takes advantage of the existing Scheme scoping rules and macro system for
more complex cases (in the rare cases where they are needed).</p>
<p>It would be possible to extend curly-infix to provide a full fixed
precedence system (e.g., if an expression is mixed,
attempt to use various precedence rules).
However, such capabilities would be extensions beyond this SRFI.
<p>Note that curly-infix includes support for unary operators, but again,
they are without precedence.
As a result, they must be grouped separately.
This does not lead to hard-to-read expressions, however.
Examples of simple curly-infix lists combining infix and unary operations
include
<code>{-(x)&nbsp;*&nbsp;-(y)}</code>
and
<code>{-{x}&nbsp;*&nbsp;-{y}}</code>
(the notation is designed so that both work).
<p>
<p>At first David A. Wheeler, who started this project,
considered reporting an error if a simple infix
expression isn&#8217;t provided.
However, prepending &#8220;<var>nfx</var>&#8221;
is much more flexible.</p>

<h2><a name="rationale_noautodetect">Why not autodetect infix?</a></h2>
<p>Some past efforts tried to automatically detect infix operators,
but this turns out to not work well. It&#8217;s hard to express
good rules for detecting infix operators, and the rules become too
complex for users (e.g., &#8220;punctuation-only symbols&#8221;
doesn&#8217;t detect &#8220;<var>and</var>&#8221; or &#8220;<var>or</var>&#8221;).
And in
any case, if they were automatically detected, an escape mechanism
would be needed anyway -
consider <samp>(map&nbsp;-&nbsp;ns)</samp>
for getting a new list with
the numbers in <var>ns</var> negated.
Allowing the user to expressly notate when
infix was intended, using <code>{</code>...<code>}</code>,
turns out to be far more clearer
and more intuitive. In particular, curly-infix allows the use of
infix with any symbol, whenever you want... and where it&#8217;s
not convenient, you don&#8217;t need to use it. It is also very
backwards-compatible: Normal lists work normally, and if you want
infix, use <code>{</code>...<code>}</code>.</p>

<h2><a name="rationale_specialcases">Why are 0, 1, and 2 parameters special?</a></h2>
<p>The empty curly-infix list
<samp>{}</samp> is intentionally mapped to <samp>()</samp>,
as it <em>is</em> an
empty list, and this is the likely user meaning (reducing
unnecessary errors).</p>
<!-- dwheeler says: I think we have to mention n-expressions and t-expressions
here, because they are part of the rationale for these semantics. -->
<p>The one and two parameter cases are defined in part to reduce user error,
and in part to provide better support:
</p>
<ol>
<li>An &#8220;escaping&#8221;
<samp>{e}</samp> is mapped to <samp>e</samp>
so that <code>{</code>...<code>}</code> can conceptually be used
for grouping:
<samp>{{{a}&nbsp;+&nbsp;{b}}}</samp>
is equivalent to
<samp>(+&nbsp;a&nbsp;b)</samp>.
It ensures that the neoteric-expression
<samp>f{x}</samp> becomes the likely-intended <samp>(f x)</samp>,
and also makes it easy to use prefix notation; e.g.,
<samp>{&nbsp;f(x)&nbsp;}</samp> is just another way to write <samp>(&nbsp;f&nbsp;x)</samp>.
Finally, it also provides an easy escape mechanism
in sweet-expressions for symbols
that would otherwise have other meanings.</li>
<li>The &#8220;unary-operation&#8221; curly-infix list
<samp>{e&nbsp;f}</samp> &#8658; <samp>(e&nbsp;f)</samp>,
so that
<samp>{-&nbsp;x}</samp> &#8658; <samp>(-&nbsp;x)</samp>,
the likely interpretation, and also so that the neoteric-expressions like
<samp>f{-&nbsp;x}</samp> &#8658;
<samp>(f&nbsp;(-&nbsp;x))</samp>.
</li>
</ol>

<h2><a name="rationale_equal">Why use <var>equal?</var> to compare operators in a &#8220;simple&#8221; curly-infix-list for equality?</a></h2>
<p>
Operators are compared using <var>equal?</var> so that
constructs like <samp>,op</samp> are legal operators,
e.g., <samp>{x&nbsp;,op&nbsp;y&nbsp;,op&nbsp;z}</samp>.
Note that unfortunately if the operator construct contains a cycle, it might not terminate
if <var>equal?</var> does not terminate in the presence of cycles.
This was specified this way so that implementors
could use the normal Scheme <var>equal?</var> comparison instead of
having to implement a special comparison operator just for this
particular case.
</p>

<h2><a name="rationale_delimiters">Why must infix operators be delimited?</a></h2>
<p>Curly-infix requires that the infix operators be delimited (e.g., by
spaces). This is consistent with Lisp history and current practice.
Currently, in Lisp, operators are always
delimited in traditional s-expressions (typically by left
parentheses on the left, and by whitespace on the right).
It&#8217;s impractical to do otherwise today; most Lisps,
including Scheme, allow and predefine symbols that include characters (like
&#8220;<code>-</code>&#8221;) that are typically used for infix operators.
Many developers put space around infix operators even in languages
that don&#8217;t require them, so syntactically requiring them is no burden.
In short, it is difficult to allow infix operators
without delimiters, and the visual results are the same as many
real-world uses in other languages, so the result appears quite
customary to typical software developers.</p>

<h2><a name="rationale_curlyfooconvention">Why the <var>curly-foo</var> convention?</a></h2>

<p>
We would like to have a convention for users to easily enable curly-infix
everywhere, e.g.,
for the default reader (e.g., <var>read</var>), read-eval-print loop (REPL),
and loader (e.g., <var>load</var>).
Our ideal would be that implementations would
enable curly-infix in their normal
invocation, but some implementors may not want to do that.
For example, if an implementation already uses braces for a
different local extension, they may not want to immediately
switch to curly-infix in their default invocation.
Thus, if implementors choose to not enable curly-infix in their default
reader, a conventional command line name &#8220;<var>curly-foo</var>&#8221;
is defined for each implementation <var>foo</var> that enables it.</p>

<p>There is simply no single option flag (for example) that
everyone could agree on to enable this.
In practice, we expect that implementations will build this capability
into their default readers and then control it via
some special flag, but we do
not want to mandate exactly how it is turned on or passed.</p>

<h2><a name="rationale_marker">Why the marker <var>#!srfi-105</var>?</a></h2>
<p>
We would like implementations to always have curly-infix enabled.
However, some implementations may have other extensions
that use <code>{</code>...<code>}</code>.
We want a simple, standard way to identify code that uses curly-infix
so that readers will switch to curly-infix if they need to switch.
<a href="http://srfi.schemers.org/srfi-105/mail-archive/msg00027.html">
This marker was recommended during discussion of SRFI-105</a>.
After all, R6RS and R7RS (draft 6) already use
<var>#!fold-case</var> and <var>#!no-fold-case</var>
as special markers to control the reader.
Using <var>#!srfi-105</var> is a simple, similar-looking marker
for a similar situation.
What&#8217;s more, it implies a reasonable convention for reader extensions:
markers that begin with <code>#!</code>, followed by an ASCII letter, should
have the rest read as an identifier (up to a whitespace)
and use that to control the reader, and <code>srfi-</code> should be
the namespace for SRFIs.
</p>

<p>
This marker need not interfere with other uses of <var>#!</var>.
<a href="http://srfi.schemers.org/srfi-22/srfi-22.html">SRFI-22</a> supports
<var>#!</var>
followed by space as a comment to the end of the line; this is supported
by several implementations, but this is easily distinguished from this
marker by the space.
Guile, clisp, and several other Lisps support
<code>#!</code>...<code>!#</code>
as a multi-line comment, enabling scripts with mixed languages and
multi-line arguments.
But in practice the <var>#!</var> is almost always
followed immediately by <code>/</code> or <code>.</code>, and other scripts
could be trivially fixed to make that so.
R6RS had a non-normative recommendation to ignore a line that began
with <var>#!/usr/bin/env</var>, as well
as a <var>#!&nbsp;/usr/bin/env</var>, but this is non-normative;
an implementation could easily implement <var>#!</var> followed by space
as an ignored line, and treat <var>#!</var> followed by
<code>/</code> or <code>.</code> differently.
Thus, implementations could trivially support simultaneously markers such as
<var>#!srfi-105</var>
to identify curly-infix, the SRFI-22 <var>#!</var>+space marker as
an ignored line, and support
<var>#!/&nbsp;...!#</var> and <var>#!.&nbsp;...!#</var> as a
multi-line comment.
Note that this SRFI does <em>not</em> mandate support or any particular
semantics for <var>#!fold-case</var>, <var>#!no-fold-case</var>,
the SRFI-22 <var>#!</var>+space convention, or
<var>#!</var> followed by a slash or period;
it is merely designed so that implementations <em>could</em>
implement them all simultaneously.
We recommend that <var>#!srfi-105</var> not be the first two characters
in a file (e.g., put a newline in front of it).
If the file were made executable, and execution was attempted,
this might confuse some systems into trying to run the
program <var>srfi-105</var>.
</p>

<p>By intent, this SRFI (including the enabling mechanism)
doesn&#8217;t use or interact with any module system at all
(including the R6RS and R7RS module systems). This is because some
implementations won&#8217;t have a module system (or at least not a
standard one). Curly-infix is an intentionally simple mechanism
that can be built into even trivial Scheme implementations.
Mandating module support is unnecessary and might inhibit its
adoption.</p>

<h2><a name="rationale_racketinfixconvention">What about the Racket &#8220;infix convention&#8221;?</a></h2>
<p><a href=
"http://docs.racket-lang.org/guide/Pairs__Lists__and_Racket_Syntax.html">
Racket allows a notation called the &#8220;infix convention&#8221;
with the form &#8220;<code>(a . operation . b)</code>&#8221;</a>. An
advantage of this alternative is that it does not use the braces,
so it might be easier to implement in Schemes which already define
<code>{</code>...<code>}</code> in a local extension. However, the Racket &#8220;infix
convention&#8221; has many problems:</p>
<ul>
<li>The Racket infix convention is much longer and more awkward
than curly-infix notation. In the Racket infix convention, every
infix operator adds 6 characters. Infix operations are a very
common operation, so convenience matters. An expression like
<samp>(1&nbsp;.&nbsp;+&nbsp;.&nbsp;2)</samp>
is far longer, and less convenient, than
<samp>{1&nbsp;+&nbsp;2}</samp>.</li>
<li>It doesn&#8217;t look like other languages or math. A human
notation should be maximally understandable to people given what
they already know.
The notation <samp>{a&nbsp;+&nbsp;b}</samp>
is much more similar to the standard notation
&#8220;a&nbsp;+&nbsp;b&#8221; than
<samp>(a&nbsp;.&nbsp;+&nbsp;.&nbsp;b)</samp>.</li>
<li>It is easy to make mistakes. If you forget a &#8220;<code>.</code>&#8221;
somewhere, you end up with the wrong result, and possibly without an
error being flagged. This notation also
makes it harder to see improper lists; improper lists are important
but rare, so it&#8217;s good to make them obvious - the Racket
infix convention makes improper lists hard to distinguish. The
Racket documentation even goes out of its way to emphasize that
infix convention use is unrelated to improper lists... which
suggests that they are easily confused.</li>
<li>Without <code>{</code>...<code>}</code>, <samp>{x}</samp> is no longer useful as an escape mechanism
for sweet-expressions (a notation that builds on curly-infix). An
alternative would be to use <samp>(. x)</samp> as an escape mechanism,
but at that point dots-in-lists become busy and confusing.</li>
<li>Racket&#8217;s implementation, according to its documentation,
does not allow multiple operations,
e.g.,
<samp>(a&nbsp;.&nbsp;+&nbsp;.&nbsp;b&nbsp;.&nbsp;+&nbsp;.&nbsp;c&nbsp;.&nbsp;+&nbsp;.&nbsp;d)</samp>.
That could be added,
but using them makes the Racket infix convention even more
unwieldy. For example, compare
<samp>(a&nbsp;.&nbsp;+&nbsp;.&nbsp;b&nbsp;.&nbsp;+&nbsp;.&nbsp;c&nbsp;.&nbsp;+&nbsp;.&nbsp;d)</samp>
to
<samp>{a&nbsp;+&nbsp;b&nbsp;+&nbsp;c&nbsp;+&nbsp;d}</samp>.</li>
<li>Even Racket users don&#8217;t use this convention often. Its
documentation says that &#8220;Racket programmers use the infix
convention sparingly&#8212;mostly for asymmetric binary operators
such as <var>&lt;</var> and <var>is-a?</var>&#8221;.
The documentation does not say why,
but its extra length and awkwardness may be part of the reason.
In any case, the fact that the Racket documentation recommends that it
be used &#8220;sparingly&#8221; does not encourage wider adoption.</li>
</ul>
<p>In short, cases where infix notation would be useful are
extremely common, so its notation should be convenient.
The Racket &#8220;infix convention&#8221; may be the
next-best notation for infix notation after curly-infix, but
it&#8217;s next-best, and we should strive for the <em>best</em>
available notation for such a common need.
Curly-infix does not <em>conflict</em> with the
Racket infix convention; implementations could implement both.
We recommend that an implementation that
implements the Racket infix convention should also allow multiple
operands and use curly-infix semantics for them, pretending that
<samp>.&nbsp;op&nbsp;.</samp>
is a single parameter.
In that case,
<samp>(a&nbsp;.&nbsp;+&nbsp;.&nbsp;b&nbsp;.&nbsp;+&nbsp;.&nbsp;c)</samp>
would map to
<samp>(+&nbsp;a&nbsp;b&nbsp;c)</samp>,
and
<samp>(a&nbsp;.&nbsp;+&nbsp;.&nbsp;b&nbsp;.&nbsp;*&nbsp;.&nbsp;c)</samp>
would map to
<samp>(nfx&nbsp;a&nbsp;+&nbsp;b&nbsp;*&nbsp;c)</samp>.
Note that the existence of the Racket &#8220;infix
convention&#8221; is additional evidence of the <em>need</em> for a
standard infix convention; many have separately created mechanisms
to try to provide infix support.</p>

<h2><a name="rationale_six">What about Gambit&#8217;s &#8220;Scheme Infix eXtension (SIX)&#8221;?</a></h2>
<p>
The Gambit reader includes a notation called the
<a href="http://www.iro.umontreal.ca/~gambit/doc/gambit-c.html#Scheme-infix-syntax-extension">&#8220;Scheme Infix eXtension (SIX)&#8221;</a>
that supports infix notation. SIX expressions begin with a backslash.</p>

<p>Like curly-infix, SIX is a reader extension.
But SIX has a number of problems compared to curly-infix:
</p>
<ul>
<li>SIX has a long, complex grammar, requiring users to remember a complex grammar, and requiring a far more complex implementation.  Curly-infix, by contrast, is extremely simple.</li>
<li>SIX is inflexible.  It only supports a fixed set of operators, and
users cannot easily use other operators inside its notation.
SIX even defines a small set of types and control structures
which cannot be extended.
People can easily create new operations;
it&#8217;s important that an infix system
be able to immediately use them.</li>
<li>SIX does not generate standard Scheme expressions, and thus it does
not interact well with macros and quoting.
SIX generates special markers when given infix expressions, and they
must then be processed later for use.
For example, in SIX, using an infix <samp>+</samp> in the input
generates <samp>six.x+y</samp>, not <samp>+</samp>, in the read result.
This means that macros may have to be specially designed to work with SIX.
In contrast, in curly-infix, <samp>{x&nbsp;+&nbsp;y}</samp> actually
generates <samp>(+&nbsp;x&nbsp;y)</samp>, so curly-infix works in a better
way with other macros and with quoting rules.</li>
</ul>

<p>
Like Racket, SIX does demonstrate that there is a <em>need</em> for
an infix notation that can be used in Scheme.
</p>

<p>A system could simultaneously implement curly-infix and SIX.
However, curly-infix is far simpler, is more flexible (e.g., by allowing
arbitrary symbols), and works much more easily with macros and quoting.
Thus, we believe that curly-infix is the better system and more
appropriate for standardization across Scheme implementations.</p>

<h2><a name="rationale_guile">What about Guile 1.4&#8217;s &#8220;reading infix&#8221; module?</a></h2>
<p><a href="http://gnuvola.org/software/guile/doc/index.html">Guile 1.4.x
at gnuvola.org</a> is self-described as a
&#8220;(somewhat amicable) fork from the official Guile&#8221;.
It includes
<a href="http://gnuvola.org/software/guile/doc/Reading-Infix.html">support
for reading infix expressions</a>.
Once activated, infix expressions are surrounded by #[ and ].
Infix are surrounded by whitespace.
It supports precedence, which sounds like an advantage,
but operators must be registered before use (and few are predefined),
creating an opportunity for terrible errors if the expression
is read first.
There is also the opportunity for serious problems if different programs
are written assuming different precedence levels.
Inside the infix notation a very different language is used
(e.g., parentheses are used for grouping instead of necessarily
creating lists, and parameters are separated by commas),
so it is unclear how well
it would work with other Scheme features such as quasiquotation.
</p>


<p>The guile 1.4 reading infix module has a more complex grammar
requiring a more complex implementation and understanding.
Its registration system creates serious problems when trying to use it
for larger systems.
This infix notation has not been accepted into the version of
guile used by most people, so it is very much not portable.
But perhaps the biggest problem is that this notation is fundamentally
not homoiconic; it is harder to determine where lists begin and end
with it.</p>

<p>
Like Racket and SIX, this module does demonstrate
that there is a <em>need</em> for
an infix notation that can be used in Scheme.
</p>

<p>In contrast, curly-infix is simpler,
requires no registration system or other complexities,
works more clearly with macros and quasiquotation, and
has the general advantage of being homoiconic.</p>

<h2><a name="rationale_neoteric">Why neoteric-expressions?</a></h2>
<p>
Lisp&#8217;s standard notation is different
from &#8220;normal&#8221; notation
in that the parentheses <em>precede</em> the function name,
rather than follow it.
Others have commented that
it&#8217;d be valueable to be able to say
<samp>name(x)</samp> instead of <samp>(name x)</samp>:</p>
<ul>
<li><a href="http://sourceware.org/ml/guile/2000-07/msg00155.html" rel="nofollow">Jorgen &#8220;forcer&#8221; Schaefer argues that
this is a more serious problem than
the lack of infix notation</a>;
on July 2000 he said
&#8220;I think most people would like Scheme
a lot better
if they could say lambda (expression) ...  instead of (lambda (expression) ...&#8221;
</li>
<li>
Peter Norvig had a reader implementation
in which
&#8220;if a function name ends with an open parentheses,
move it inside the list (when converting to an s-expression)&#8221;.
This means that <samp>(fact x)</samp> and
<samp>fact(x)</samp> will mean the same thing.
</li>
<li>
<a href="http://portal.acm.org/ft_gateway.cfm?id=174185&amp;type=pdf&amp;coll=portal&amp;dl=ACM&amp;CFID=72577012&amp;CFTOKEN=50239143" rel="nofollow">Skill</a> from Cadence,
a proprietary Lisp-based extension language,
also supports name-prefixing.
</li>
</ul>

<p>
Neoteric-expressions allow users to use a more traditional-looking notation for
function calls.
Again, quoting rules and macros continue to work as usual.
<ul>
<li>
The prefixed <samp>e(...)</samp> form provides
a more traditional-looking format for function calls,
 e.g., <samp>-(x)</samp> instead of <samp>(-&nbsp;x)</samp>.</li>
<li>
The prefixed <samp>e{...}</samp> form simplifies
combining function calls and infix expressions
when there is only one parameter to the function call.
This is a common case;
for example, &#8220;<var>not</var>&#8221;
(which is normally given only one parameter)
often encloses infix &#8220;<var>and</var>&#8221; and
&#8220;<var>or</var>&#8221;.
Thus,
<samp>f{n&nbsp;-&nbsp;1}</samp>
&#8658;
<samp>(f&nbsp;(-&nbsp;n&nbsp;1))</samp>.
When there is more than one function parameter,
use the normal term-prefixing format instead, e.g.,
<samp>f({x&nbsp;-&nbsp;1}&nbsp;{y&nbsp;-&nbsp;1})</samp> &#8658;
<samp>(f&nbsp;(-&nbsp;x&nbsp;1)&nbsp;(-&nbsp;y&nbsp;1))</samp>.
</li>
<li>
Prefixed square brackets <samp>e[...]</samp> &#8658;
<samp>(bracketaccess&nbsp;e&nbsp;...)</samp>.
This is intended to simplify use of indexed arrays, associative arrays, and similar constructs.
</li>
</ul>
<p>
The <samp>(.&nbsp;e)</samp> rule handles expressions like <samp>read(.&nbsp;port)</samp>,
ensuring that they map to <samp>(read&nbsp;.&nbsp;port)</samp>.
If <samp>(.&nbsp;x)</samp> didn&#8217;t mean <samp>x</samp>, then it would
be easy to get this case wrong.  Also, if someone wanted to build on
top of an existing reader, they would have to reimplement parts of the
list-processing system if this wasn&#8217;t handled.
It is already true that
<samp>(.&nbsp;x)</samp> is <samp>x</samp> in guile,
so there was already a working example that this
is a reasonable extension.  In fact, in a typical implementation of a
list reader, it takes extra effort to <em>prevent</em> this extension,
so this is a relatively easy extension to include.</p>

<h2><a name="rationale_comma">Comma-separated parameters</a></h2>
<p>
It would be possible to define neoteric-expressions to have
comma-separated values in a function call; this would make it even
more similar to traditional function call notation. A simple way would be to simply
remove all commas, but this would interfere with <code>,</code>-lifting,
and thus was immediately rejected.
</p>
<p>A better rule, that would indeed work, would be to <em>require</em>
each parameter to end with a comma, and then remove that ending comma.
However, this rule:</p>
<ul>
<li>would obscure any comma used for <code>,</code>-lifting
(making them hard to find).</li>
<li>is inconsistent with &#8220;normal&#8221; Lisp lists, which do
not use commas this way, as well as being inconsistent with the simple
space-separated parameters of sweet-expressions. This
would make it harder to switch formats and possibly hamper adoption.</li>
<li>clutters the code and is extremely inconvenient.
Parameters are very common, so creating an additional required character for
every parameter turned out to be unpleasant to read and write
when this was tried in experimentation.</li>
<li>is completely unnecessary.  Whitespace is quite sufficient (and clear)
for syntactically separating parameters.</li>
</ul>
<p>Many other languages do use commas, but they are required in those
languages because infix operators are not surrounded by any marker.
Since infix operations are already surrounded by
<code>{</code>...<code>}</code> in our notation,
there is no need for the additional commas for parameter separation.</p>
<p>Experimentation found that separating parameters solely by whitespace
worked well, so that approach was selected.</p>

<h2><a name="rationale_other_neoteric">Other comments on neoteric-expressions</a></h2>
<p>Originally the prefix had to be a symbol or list.  The theory was
that by ignoring others, the sweet-reader would be backwards-compatible
with some badly-formatted code, and some errors might not result in
incorrectly-interpreted expressions.  But this was an odd limitation,
and in some cases other prefixes made sense (e.g., for strings).
This was changed to eliminate the inconsistency.</p>

<p>Neoteric-expressions used to be called &#8220;modern-expressions&#8221;.
But some people didn&#8217;t like that name,
and the obvious abbreviation (&#8220;m-expression&#8221;)
was easily confused with the original Lisp M-expression language.
So the name was changed to neoteric, which has a similar meaning and
abbreviates nicely.
It wasn&#8217;t called &#8220;function-expressions&#8221; because
&#8220;f-expressions&#8221; are previously used
(and can sound bad if said quickly),
and they weren&#8217;t called &#8220;prefix-expressions&#8221;
because &#8220;p-expressions&#8221;
sound like &#8220;pee-expressions&#8221;.
It&#8217;s not called &#8220;name-prefix&#8221; because
the prefix need not be a name.
There is absolutely no truth to the rumor that the notation
was developed by a secret technologically advanced species, so
pay no attention to &#8220;Microcosmic God&#8221; by Theodore Sturgeon :-).
</p>

<p>The neoteric rules do introduce the risk of someone inserting
a space between the function name and the opening <code>(</code>.
But whitespace is already significant as a parameter separator, so this
is consistent with how the system works anyway... this is not really a
change at all.</p>

<p>Obviously, this is trivial to parse.  We don&#8217;t lose any power,
because this is completely optional -- we only use it when we want to,
and we can switch back to the traditional s-expression notation if we
want to.  It&#8217;s trivially quoted... if you quote a symbol followed
by <code>(</code>, just keep going until its matching <code>)</code>,
which is essentially the same rule as before!</p>

<h2><a name="rationale_otherdetails">Other details</a></h2>
<p>There is no requirement that writers (e.g., &#8220;<var>write</var>&#8221;
or a pretty-printer) write out curly-infix-expressions. They may
choose to do so, e.g., for lists of length 3-6 whose car is the
symbol &#8220;<var>and</var>&#8221;,
the symbol &#8220;<var>or</var>&#8221;, or a
punctuation-only symbol. However, it would probably be wise to wait
until many implementations can handle c-expressions.</p>
<p>Curly-infix is designed so that it can work on other Lisps as
well. We even have a working implementation in Common Lisp.</p>
<p>Curly-infix is an unusually simple mechanism, but like much of
any Lisp-based language, its power comes from its simplicity.</p>

<h1><a name="specification">Specification</a></h1>
<p>&#8220;<dfn>Curly-infix-expressions</dfn>&#8221; or &#8220;<dfn>c-expressions</dfn>&#8221; are
s-expressions with an additional notation: The curly-infix list.
A curly-infix list is syntactically almost identical to a regular list,
but it is surrounded by braces instead of by parentheses, and instead of
a sequence of s-expressions it contains a sequence of
neoteric-expressions (which add support for formats like <samp>f(x)</samp>).
Once a curly-infix list is read, it is mapped differently than a
regular list by a curly-infix reader:</p>
<ol>
<li>A <dfn>simple</dfn> curly-infix list has an odd number of
parameters, at least three parameters, and all even parameters are
&#8220;<var>equal?</var>&#8221;.
If there is more than one even parameter, and
an even parameter contains a cycle, then
the <var>equal?</var> comparison <em>must</em> terminate
if <var>equal?</var> terminates (otherwise
the comparison <em>may</em> terminate).
A simple curly-infix list is mapped by
the reader into a list with the first even parameter
followed by the odd parameters.
E.g.,
<samp>{n&nbsp;&lt;=&nbsp;2}</samp> &#8658;
<samp>(&lt;=&nbsp;n&nbsp;2)</samp>,
and
<samp>{2&nbsp;*&nbsp;3&nbsp;*&nbsp;4}</samp> &#8658;
<samp>(*&nbsp;2&nbsp;3&nbsp;4)</samp>.</li>
<li>The <dfn>empty</dfn> curly-infix list
<samp>{}</samp> is mapped to the empty list <samp>()</samp>.</li>
<li>An <dfn>escaping</dfn> curly-infix list
<samp>{e}</samp> is mapped to <samp>e</samp>.
E.g., <samp>{5}</samp> is mapped to <samp>5</samp>.</li>
<li>A <dfn>unary-operation</dfn> curly-infix list
<samp>{e1&nbsp;e2}</samp>
is mapped to
<samp>(e1&nbsp;e2)</samp>.
E.g.,
<samp>{-&nbsp;x}</samp> &#8658;
<samp>(-&nbsp;x)</samp>.</li>
<li>The mapping of a curly-infix list beginning with the symbol
&#8220;<var>.</var>&#8221; is unspecified.
(Note: the reference implementation maps
<samp>{.&nbsp;e}</samp> to <samp>e</samp>.)
</li>
<li>Any other curly-infix list (including all other improper lists) is
<dfn>mixed</dfn>.  A mixed curly-infix list <em>must</em> be mapped to that list with &#8220;<var>nfx</var>&#8221; added to its front.
E.g.,
<samp>{q&nbsp;+&nbsp;r&nbsp;*&nbsp;s}</samp>
is mapped to
<samp>(nfx&nbsp;q&nbsp;+&nbsp;r&nbsp;*&nbsp;s)</samp>, and
<samp>{q&nbsp;+&nbsp;r&nbsp;.&nbsp;s}</samp>
is mapped to
<samp>(nfx&nbsp;q&nbsp;+&nbsp;r&nbsp;.&nbsp;s)</samp>.
</li>
</ol>
<p>
Here is the precise definition of a curly-infix list
(which is nearly identical to a traditional list):
</p>
<table border="0">
<tr>
<td valign="top">
curly-infix-list&nbsp;&#8594;
</td>
<td valign="top">
&#8220;<tt>{</tt>&#8221;
&lt;whitespace&gt;*
[ &lt;n-expression&gt;
[ &lt;whitespace&gt;+ &lt;n-expression&gt; ]*
[ &lt;whitespace&gt;+ .
  &lt;whitespace&gt;+ &lt;n-expression&gt; ]
&lt;whitespace&gt;* ]
&#8220;<tt>}</tt>&#8221;
</td>
</tr>
</table>
<!--
it begins with &#8220;{&#8221;, optional whitespace,
a sequence of zero or more whitespace-separated
<em>neoteric-expressions</em>, optionally more whitespace (if there
were any neoteric-expressions), and
a matching &#8220;}&#8221;.
-->
<p>
A &#8220;<dfn>neoteric-expression</dfn>&#8221; or &#8220;<dfn>n-expression</dfn>&#8221;
is a curly-infix-expression, with the following modifications where
<var>e</var> is any datum expression:
</p>
<ol>
<li>
<samp>e(...)</samp> &#8658;
<samp>(e&nbsp;...)</samp>.
E.g.,
<samp>f(1&nbsp;2)</samp> &#8658;
<samp>(f&nbsp;1&nbsp;2)</samp>,
<samp>exit()</samp> &#8658;
<samp>(exit)</samp>, and
<samp>read(.&nbsp;port)</samp> &#8658;
<samp>(read&nbsp;.&nbsp;port)</samp>.</li>
<li>
<samp>e{}</samp> &#8658; <samp>(e)</samp>
when there are zero or more whitespace characters
within the braces;
otherwise,
<samp>e{...}</samp> &#8658; <samp>(e&nbsp;{...})</samp>.
E.g.,
<samp>f{n&nbsp;-&nbsp;1}</samp>
&#8658;
<samp>(f&nbsp;{n&nbsp;-&nbsp;1})</samp>
&#8658;
<samp>(f&nbsp;(-&nbsp;n&nbsp;1))</samp>,
and
<samp>g{-&nbsp;x}</samp>
&#8658;
<samp>(g&nbsp;(-&nbsp;x))</samp>.</li>
<li><samp>e[...]</samp> &#8658;
<samp>(bracketaccess&nbsp;e&nbsp;...)</samp></li>
<li>There must be no whitespace between <samp>e</samp> and the open paired character.</li>
<li>An unprefixed <samp>(&nbsp;.&nbsp;e)</samp> must evaluate as <samp>e</samp>.</li>
<li>
These recurse within lists,
so lists contains sequences
of zero or more <em>neoteric</em> expressions,
not s-expressions.
<li>
These recurse left-to-right.
E.g.,
<samp>f{n&nbsp;-&nbsp;1}(x)</samp>
&#8658;
<samp>f({n&nbsp;-&nbsp;1})(x)</samp>
&#8658;
<samp>(f&nbsp;(-&nbsp;n&nbsp;1))(x)</samp>
&#8658;
<samp>((f&nbsp;(-&nbsp;n&nbsp;1))&nbsp;x)</samp>
</li>
</ol>
<p>Here are some examples of c-expressions (note all operators in curly-infix are delimited):</p>
<ul>
<li><samp>{n&nbsp;&lt;=&nbsp;2}</samp> &#8658;
    <samp>(&lt;=&nbsp;n&nbsp;2)</samp></li>
<li><samp>{a&nbsp;+&nbsp;b&nbsp;+&nbsp;c}</samp>
&#8658;
<samp>(+&nbsp;a&nbsp;b&nbsp;c)</samp>.</li>
<li><samp>{x&nbsp;,op&nbsp;y&nbsp;,op&nbsp;z}</samp> &#8658;
    <samp>(,op&nbsp;x&nbsp;y&nbsp;z}</samp>
<li><samp>{a * {b + c}}</samp> &#8658; <samp>(* a (+ b c))</samp></li>
<li><samp>{x eqv? &#96;a}</samp> &#8658; <samp>(eqv? x &#96;a)</samp></li>
<li><samp>{(- a) / b}</samp> &#8658; <samp>(/ (- a) b)</samp></li>
<li><samp>{-(a) / b}</samp> &#8658; <samp>(/ (- a) b)</samp> as well</li>
<li><samp>{(f a b) + (g h)}</samp> &#8658; <samp>(+ (f a b) (g h))</samp></li>
<li><samp>{f(a b) + g(h)}</samp> &#8658; <samp>(+ (f a b) (g h))</samp> as well</li>
<li><samp>&#39;{a + f(b) + x}</samp> &#8658; <samp>&#39;(+ a (f b) x)</samp></li>
<li><samp>{{a &gt; 0} and {b &gt;= 1}}</samp> &#8658;
<samp>(and (&gt; a 0) (&gt;= b 1))</samp></li>
<li><samp>{&#39;f(x)}</samp> &#8658; <samp>(quote&nbsp;(f&nbsp;x))</samp></li>
</ul>

<p>A <dfn>curly-infix reader</dfn> is a datum reader
that can correctly read and map curly-infix-expressions.
A curly-infix reader <em>must</em>
include the braces &#8220;<code>{</code>&#8221; and
&#8220;<code>}</code>&#8221; as delimiters.</p>

<p>
An implementation of this SRFI <em>must</em> accept the marker
<var>#!srfi-105</var> followed by a whitespace character.
This marker (including the trailing whitespace character)
is consumed and considered whitespace;
after reading this marker, the reader <em>must</em> accept
curly-infix expressions in subsequent datums
until it reaches an end-of-file or some other conflicting marker
(no conflicting marker is specified here).
We encourage implementations to <em>always</em>
implement curly-infix expressions, even when the marker is not received.
However, portable applications <em>must</em>
include this marker before any curly-infix expressions.
We recommend that portable applications not use this marker as the
first characters of a file (e.g., they should precede it with a newline).
</p>

<p>The &#8220;<dfn>standard readers</dfn>&#8221;
are the datum reader used by the REPL,
the datum readers defined by the relevant Scheme standards
(such as &#8220;<var>read</var>&#8221; and where applicable
&#8220;<var>get-datum</var>&#8221;),
and the readers used to load user-supplied code
as defined by the relevant Scheme standards
(e.g., the reader used by &#8220;<var>load</var>&#8221;
and module-loading mechanisms for user code).
The standard readers are <dfn>curly-infix enabled</dfn> if the standard
readers are curly-infix readers.</p>

<p>
An implementation of this SRFI <em>must</em>
have its standard readers be curly-infix enabled.
We encourage implementations&#8217; <em>default</em> invocation to
have their standard readers be curly-infix enabled,
but this is <em>not</em> required.
If the standard readers are not curly-infix enabled
in an implementation&#8217;s default invocation,
then if it can be invoked from a command line via the command
&#8220;<var>foo</var>&#8221;, the implementation
<em>must</em> provide an alternative command &#8220;<var>curly-foo</var>&#8221;
(the command prefixed with &#8220;<code>curly-</code>&#8221;) in which
its standard readers <em>are</em> curly-infix enabled.
In addition, if the implementation is invokable as
a graphical user interface (GUI), it
<em>must</em> provide a documented means to ensure that its
standard readers are curly-infix enabled.
</p>

<p>
An implementation <em>must not</em>, by default, bind the symbol
&#8220;<var>nfx</var>&#8221; to a procedure, macro, or syntax
that <em>cannot</em> be overridden.
This symbol is reserved for use by library writers
(in the case of a library-based implementation of this SRFI,
this symbol is reserved for use by <em>other</em> libraries)
and application writers.
</p>
<p>
<em>However</em>, an implementation <em>may</em> provide a default
<em>library</em> that binds the &#8220;<var>nfx</var>&#8221; symbol
(as it is then a library, this case actually falls under
the &#8220;reserved for use by library writers&#8221; clause above).
Application writers and other library writers
using that implementation
are then free to use or not use
the implementation&#8217;s provided &#8220;<var>nfx</var>&#8221;.
An implementation may even provide more than one, if they so desire.
For a library-based implementation of this SRFI,
any &#8220;<var>nfx</var>&#8221; implementation or
implementations <em>may</em> be provided,
as long as the &#8220;<var>nfx</var>&#8221; symbol can be
rebound by users of that library.
</p>

<p>
Implementations <em>may</em> provide the procedure
<var>(curly-infix-read .  port)</var> as a curly-infix reader.
</p>

<p>Note that, by definition, this SRFI modifies lexical syntax.</p>

<h1><a name="reference-implementation">Reference implementation</a></h1>
<p>The implementation below is portable, with the exception that
Scheme provides no standard mechanism to override
<code>{</code>...<code>}</code> in its
built-in reader. Thus, implementations will typically have a
modified reader that detects &#8220;<code>{</code>&#8220;, starts reading a list
until its matching &#8220;<code>}</code>&#8221;, and then calls <var>process-curly</var>
defined below. We recommend that implementations <em>always</em> do
this, but an implementation must at least activate this behavior
when &#8220;<var>curly-foo</var>&#8221; is invoked
or when they read <var>#!srfi-105</var>.
<p>This reference implementation is SRFI type 2: &#8220;A
mostly-portable solution that uses some kind of hooks provided in
some Scheme interpreter/compiler. In this case, a detailed
specification of the hooks must be included so that the SRFI is
self-contained.&#8221;</p>
<pre>
  ; Return true if lyst has an even # of parameters, and the (alternating)
  ; first parameters are "op".  Used to determine if a longer lyst is infix.
  ; If passed empty list, returns true (so recursion works correctly).
  (define (even-and-op-prefix? op lyst)
    (cond
      ((null? lyst) #t)
      ((not (pair? lyst)) #f)
      ((not (equal? op (car lyst))) #f) ; fail - operators not the same
      ((not (pair? (cdr lyst)))  #f) ; Wrong # of parameters or improper
      (#t   (even-and-op-prefix? op (cddr lyst))))) ; recurse.


  ; Return true if the lyst is in simple infix format
  ; (and thus should be reordered at read time).
  (define (simple-infix-list? lyst)
    (and
      (pair? lyst)           ; Must have list;  '() doesn't count.
      (pair? (cdr lyst))     ; Must have a second argument.
      (pair? (cddr lyst))    ; Must have a third argument (we check it
                             ; this way for performance)
      (even-and-op-prefix? (cadr lyst) (cdr lyst)))) ; true if rest is simple

  ; Return alternating parameters in a list (1st, 3rd, 5th, etc.)
  (define (alternating-parameters lyst)
    (if (or (null? lyst) (null? (cdr lyst)))
      lyst
      (cons (car lyst) (alternating-parameters (cddr lyst)))))

  ; Not a simple infix list - transform it.  Written as a separate procedure
  ; so that future experiments or SRFIs can easily replace just this piece.
  (define (transform-mixed-infix lyst)
     (cons 'nfx lyst))

  ; Given curly-infix lyst, map it to its final internal format.
  (define (process-curly lyst)
    (cond
     ((not (pair? lyst)) lyst) ; E.G., map {} to ().
     ((null? (cdr lyst)) ; Map {a} to a.
       (car lyst))
     ((and (pair? (cdr lyst)) (null? (cddr lyst))) ; Map {a b} to (a b).
       lyst)
     ((simple-infix-list? lyst) ; Map {a OP b [OP c...]} to (OP a b [c...])
       (cons (cadr lyst) (alternating-parameters lyst)))
     (#t  (transform-mixed-infix lyst))))


  ; ------------------------------------------------
  ; Key procedures to implement neoteric-expressions
  ; ------------------------------------------------

  ; Read the "inside" of a list until its matching stop-char, returning list.
  ; stop-char needs to be closing paren, closing bracket, or closing brace.
  ; This is like read-delimited-list of Common Lisp.
  ; This implements a useful extension: (. b) returns b.
  (define (my-read-delimited-list stop-char port)
    (let*
      ((c   (peek-char port)))
      (cond
        ((eof-object? c) (read-error "EOF in middle of list") '())
        ((eqv? c #\;)
          (consume-to-eol port)
          (my-read-delimited-list stop-char port))
        ((my-char-whitespace? c)
          (read-char port)
          (my-read-delimited-list stop-char port))
        ((char=? c stop-char)
          (read-char port)
          '())
        ((or (eq? c #\)) (eq? c #\]) (eq? c #\}))
          (read-char port)
          (read-error "Bad closing character"))
        (#t
          (let ((datum (neoteric-read port)))
            (cond
               ((eq? datum '.)
                 (let ((datum2 (neoteric-read port)))
                   (consume-whitespace port)
                   (cond
                     ((eof-object? datum2)
                      (read-error "Early eof in (... .)\n")
                      '())
                     ((not (eqv? (peek-char port) stop-char))
                      (read-error "Bad closing character after . datum"))
                     (#t
                       (read-char port)
                       datum2))))
               (#t
                   (cons datum
                     (my-read-delimited-list stop-char port)))))))))


  ; Implement neoteric-expression's prefixed (), [], and {}.
  ; At this point, we have just finished reading some expression, which
  ; MIGHT be a prefix of some longer expression.  Examine the next
  ; character to be consumed; if it's an opening paren, bracket, or brace,
  ; then the expression "prefix" is actually a prefix.
  ; Otherwise, just return the prefix and do not consume that next char.
  ; This recurses, to handle formats like f(x)(y).
  (define (neoteric-process-tail port prefix)
      (let* ((c (peek-char port)))
        (cond
          ((eof-object? c) prefix)
          ((char=? c #\( ) ; Implement f(x).
            (read-char port)
            (neoteric-process-tail port
                (cons prefix (my-read-delimited-list #\) port))))
          ((char=? c #\[ )  ; Implement f[x]
            (read-char port)
            (neoteric-process-tail port
                  (cons 'bracketaccess
                    (cons prefix
                      (my-read-delimited-list #\] port)))))
          ((char=? c #\{ )  ; Implement f{x}. Balance }
            (neoteric-process-tail port
              (let ((tail (neoteric-read port)))
                (if (eqv? tail '())
                  (list prefix) ; Map f{} to (f), not (f ()).
                  (list prefix tail)))))
          (#t prefix))))

  (define (neoteric-read . port)
    (if (null? port)
      (neoteric-read-real (current-input-port))
      (neoteric-read-real (car port))))
  
  ; This is the "real" implementation of neoteric-read
  ; (neoteric-read just figures out the port and calls neoteric-read-real).
  ; It implements an entire reader, as a demonstration, but if you can
  ; update your existing reader you should just update that instead.
  ; This is a simple R5RS reader, with a few minor (common) extensions.
  ; The key part is that it implements [] and {} as delimiters, and
  ; after it reads in some datum (the "prefix"), it calls
  ; neoteric-process-tail to see if there's a "tail".
  (define (neoteric-read-real port)
    (let*
      ((c (peek-char port))
       (prefix
         ; This cond is a normal Scheme reader, puts result in "prefix"
         ; This implements "read-expression-as-usual" as described above.
        (cond
          ((eof-object? c) c)
          ((char=? c #\;)
            (consume-to-eol port)
            (neoteric-read-real port))
          ((my-char-whitespace? c)
            (read-char port)
            (neoteric-read-real port))
          ((char=? c #\( )
             (read-char port)
             (my-read-delimited-list #\) port))
          ((char=? c #\) )
             (read-char port)
             (read-error "Closing parenthesis without opening")
             (neoteric-read-real port))
          ((char=? c #\[ )
             (read-char port)
             (my-read-delimited-list #\] port))
          ((char=? c #\] )
             (read-char port)
             (read-error "Closing bracket without opening")
             (neoteric-read-real port))
          ((char=? c #\{ )
            (read-char port)
            (process-curly
                (my-read-delimited-list #\} port)))
          ((char=? c #\} )
             (read-char port)
             (read-error "Closing brace without opening")
             (neoteric-read-real port))
          ((char=? c #\") ; Strings are delimited by ", so can call directly
            (default-scheme-read port))
          ((char=? c #\')
            (read-char port)
            (list 'quote (neoteric-read-real port)))
          ((char=? c #\`)
            (read-char port)
            (list 'quasiquote (neoteric-read-real port)))
          ((char=? c #\,)
            (read-char port)
              (cond
                ((char=? #\@ (peek-char port))
                  (read-char port)
                  (list 'unquote-splicing (neoteric-read-real port)))
               (#t
                (list 'unquote (neoteric-read-real port)))))
          ((ismember? c digits) ; Initial digit.
            (read-number port '()))
          ((char=? c #\#) (process-sharp port))
          ((char=? c #\.) (process-period port))
          ((or (char=? c #\+) (char=? c #\-))  ; Initial + or -
             (read-char port)
             (if (ismember? (peek-char port) digits)
               (read-number port (list c))
               (string->symbol (fold-case-maybe port
                 (list->string (cons c
                    (read-until-delim port neoteric-delimiters)))))))
          (#t ; Nothing else.  Must be a symbol start.
            (string->symbol (fold-case-maybe port
              (list->string
                (read-until-delim port neoteric-delimiters))))))))
      ; Here's the big change to implement neoteric-expressions:
      (if (eof-object? prefix)
        prefix
        (neoteric-process-tail port prefix))))


  ; Modify the main reader so that [] and {} are also delimiters, and so
  ; that when #\{ is detected, read using my-read-delimited-list
  ; any list from that port until its matching #\}, then process
  ; that list with "process-curly", like this:
  ;   (process-curly (my-read-delimited-list #\} port))

</pre>

<h1><a name="references">References</a></h1>
<p>The readable project website has more information: <a href=
"http://readable.sourceforge.net">http://readable.sourceforge.net</a></p>

<h1><a name="acknowledgments">Acknowledgments</a></h1>
<p>We thank all the participants on the &#8220;readable-discuss&#8221; mailing list.</p>

<h1 id="copyright">Copyright</h1>
<p>Copyright (C) 2012 David A. Wheeler and Alan Manuel K. Gloria.
All Rights Reserved.</p>
<p>Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use, copy,
modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY
OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>
    <hr/>
    <address>Editor: <a href="mailto:srfi-editors at srfi dot schemers dot org">
             Mike Sperber</a></address>
</body>
</html>
<!--
Note: HTML 3.2 has no attribute "id", so using <a name="ID">...</a>.
-->
<!--
Note: &apos; is in XML 1.0 and HTML 4.0, but not in HTML 3.2, so
we cannot use "&apos;" to represent it.  Instead, this file
uses &#39; for single vertical apostrophe.  That way, it will
not be converted later to curly quotes by "quoter" and similar tools.
-->

